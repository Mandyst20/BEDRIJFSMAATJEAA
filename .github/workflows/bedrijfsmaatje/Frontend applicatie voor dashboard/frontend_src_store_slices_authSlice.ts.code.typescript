import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import axios from 'axios';
import { RootState } from '../index';
import { setUser } from './userSlice';
import { setSubscription } from './subscriptionSlice';
import api from '../../utils/api';

// Types
interface AuthState {
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
}

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterData {
  name: string;
  email: string;
  password: string;
  company: string;
  phone?: string;
  industry?: string;
  companySize?: string;
}

interface AuthResponse {
  success: boolean;
  token: string;
  message?: string;
}

// Initial state
const initialState: AuthState = {
  token: null,
  isAuthenticated: false,
  loading: false,
  error: null,
};

// Async thunks
export const login = createAsyncThunk<
  AuthResponse,
  LoginCredentials,
  { rejectValue: string }
>('auth/login', async (credentials, { dispatch, rejectWithValue }) => {
  try {
    const response = await api.post<AuthResponse>('/auth/login', credentials);
    
    // Als login succesvol is, haal gebruikersgegevens op
    if (response.data.success) {
      // Token opslaan in axios defaults
      api.defaults.headers.common['Authorization'] = `Bearer ${response.data.token}`;
      
      // Gebruikersgegevens ophalen
      const userResponse = await api.get('/auth/me');
      
      if (userResponse.data.success) {
        dispatch(setUser(userResponse.data.data.user));
        dispatch(setSubscription(userResponse.data.data.subscription));
      }
    }
    
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return rejectWithValue(
        error.response.data.error?.message || 'Inloggen mislukt'
      );
    }
    return rejectWithValue('Er is een fout opgetreden bij het inloggen');
  }
});

export const register = createAsyncThunk<
  AuthResponse,
  RegisterData,
  { rejectValue: string }
>('auth/register', async (userData, { rejectWithValue }) => {
  try {
    const response = await api.post<AuthResponse>('/auth/register', userData);
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return rejectWithValue(
        error.response.data.error?.message || 'Registratie mislukt'
      );
    }
    return rejectWithValue('Er is een fout opgetreden bij het registreren');
  }
});

export const forgotPassword = createAsyncThunk<
  { success: boolean; data: string },
  { email: string },
  { rejectValue: string }
>('auth/forgotPassword', async ({ email }, { rejectWithValue }) => {
  try {
    const response = await api.post<{ success: boolean; data: string }>(
      '/auth/forgotpassword',
      { email }
    );
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return rejectWithValue(
        error.response.data.error?.message || 'Wachtwoord reset aanvraag mislukt'
      );
    }
    return rejectWithValue('Er is een fout opgetreden bij het aanvragen van een wachtwoord reset');
  }
});

export const resetPassword = createAsyncThunk<
  { success: boolean; message: string },
  { password: string; resetToken: string },
  { rejectValue: string }
>('auth/resetPassword', async ({ password, resetToken }, { rejectWithValue }) => {
  try {
    const response = await api.put<{ success: boolean; message: string }>(
      `/auth/resetpassword/${resetToken}`,
      { password }
    );
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error) && error.response) {
      return rejectWithValue(
        error.response.data.error?.message || 'Wachtwoord reset mislukt'
      );
    }
    return rejectWithValue('Er is een fout opgetreden bij het resetten van het wachtwoord');
  }
});

export const logout = createAsyncThunk('auth/logout', async (_, { dispatch }) => {
  try {
    await api.get('/auth/logout');
    // Verwijder token uit axios defaults
    delete api.defaults.headers.common['Authorization'];
    
    // Reset user state
    dispatch(setUser(null));
    dispatch(setSubscription(null));
    
    return true;
  } catch (error) {
    console.error('Logout error:', error);
    return false;
  }
});

// Auth slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setToken: (state, action: PayloadAction<string | null>) => {
      state.token = action.payload;
      state.isAuthenticated = !!action.payload;
      
      // Update axios default headers
      if (action.payload) {
        api.defaults.headers.common['Authorization'] = `Bearer ${action.payload}`;
      } else {
        delete api.defaults.headers.common['Authorization'];
      }
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    // Login
    builder.addCase(login.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(login.fulfilled, (state, action) => {
      state.loading = false;
      state.token = action.payload.token;
      state.isAuthenticated = true;
    });
    builder.addCase(login.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload || 'Inloggen mislukt';
    });
    
    // Register
    builder.addCase(register.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(register.fulfilled, (state, action) => {
      state.loading = false;
      // Bij registratie krijgen we een token, maar we loggen niet automatisch in
      // De gebruiker moet eerst zijn e-mail verifiÃ«ren
    });
    builder.addCase(register.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload || 'Registratie mislukt';
    });
    
    // Logout
    builder.addCase(logout.fulfilled, (state) => {
      state.token = null;
      state.isAuthenticated = false;
    });
  },
});

// Actions
export const { setToken, clearError } = authSlice.actions;

// Selectors
export const selectAuth = (state: RootState) => state.auth;
export const selectIsAuthenticated = (state: RootState) => state.auth.isAuthenticated;
export const selectAuthLoading = (state: RootState) => state.auth.loading;
export const selectAuthError = (state: RootState) => state.auth.error;

export default authSlice.reducer;